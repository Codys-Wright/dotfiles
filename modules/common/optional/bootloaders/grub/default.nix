# GRUB Bootloader Implementation
# Supports themes, hierarchical menus, and chainloading
{
  lib,
  config,
  pkgs,
  ...
}:

let
  cfg = config.bootloaderConfig;
  helpers = cfg.helpers;

  # Generate GRUB menu entries
  generateGrubEntry =
    entry:
    let
      entryConfig = {
        os = ''
          menuentry "${entry.name}" {
            ${
              if entry.osType == "windows" then
                ''
                  search --set=root --label WINDOWS
                  chainloader +1
                ''
              else if entry.osType == "nixos" then
                ''
                  # NixOS entry will be auto-generated
                ''
              else
                ''
                  # Custom OS entry
                  search --set=root --file /boot/grub/grub.cfg --hint hd0,gpt1
                  configfile /boot/grub/grub.cfg
                ''
            }
          }
        '';

        submenu = ''
          submenu "${entry.name}" {
            ${generateSubmenuEntries entry.submenu}
          }
        '';

        generations = ''
          submenu "${entry.name}" {
            # NixOS generations will be auto-populated by NixOS
            configfile /boot/grub/generations.cfg
          }
        '';

        firmware = ''
          menuentry "${entry.name}" {
            fwsetup
          }
        '';
      };
    in
    entryConfig.${entry.type} or "";

  # Generate entries for inside submenus (simpler than main menu entries)
  generateSubmenuEntry = entry:
    if entry.type == "firmware" then
      ''
        menuentry "${entry.name}" {
          fwsetup
        }
      ''
    else if entry.type == "os" && entry.osType == "nixos" then
      ''
        menuentry "${entry.name}" {
          # NixOS recovery entry - will be auto-populated
        }
      ''
    else
      ''
        menuentry "${entry.name}" {
          # Custom entry
        }
      '';

  # Generate submenu entries (for hierarchical navigation)
  generateSubmenuEntries =
    submenuCfg:
    if submenuCfg != null then
      let
        # Check if this is a generations submenu (empty entries)
        isGenerationsMenu = submenuCfg.entries == [];
        submenuEntries = if isGenerationsMenu then
          ''
            # NixOS generations will be auto-populated here by the bootloader
            # This is a placeholder that GRUB will replace with actual generation entries
          ''
        else
          lib.concatStringsSep "\n" (map generateSubmenuEntry submenuCfg.entries);
      in
      ''
        # Submenu using ${submenuCfg.bootloader}
        ${
          if submenuCfg.bootloader == "grub" then
            submenuEntries
          else
            ''
              # Chainload to ${submenuCfg.bootloader}
              menuentry "Load ${submenuCfg.bootloader}" {
                chainloader /boot/${submenuCfg.bootloader}/bootloader.efi
              }
            ''
        }
      ''
    else
      "";

  # Generate theme configuration
  themeConfig =
    let
      themePath = helpers.getThemePath "grub" cfg.primary.theme;
    in
    lib.optionalString (cfg.primary.theme != null) ''
      # GRUB Theme Configuration (handled by NixOS theme option)
      # Theme: ${cfg.primary.theme}
    '';

  # Generate custom GRUB configuration
  customGrubConfig = ''
    # Custom GRUB Configuration Generated by Universal Bootloader System
    set timeout=${toString cfg.primary.timeout}
    set default=0

    ${themeConfig}
  '';

  # Simple test submenu for extraEntries
  testSubmenu = ''
    submenu "More Options" {
      menuentry "BIOS/Firmware Settings" {
        fwsetup
      }
      
      menuentry "Test Entry 1" {
        # Just a test entry
        echo "Test entry selected"
        sleep 2
      }
      
      menuentry "Test Entry 2" {
        # Another test entry
        echo "Another test entry"
        sleep 2
      }
    }
  '';

  # Generate custom menu entries to be inserted via extraConfig
  customMenuEntriesForConfig = 
    let
      filteredEntries = lib.filter (entry: 
        !(entry.type == "os" && entry.osType == "nixos")
      ) cfg.entries;
      sortedEntries = lib.sort (a: b: a.priority < b.priority) filteredEntries;
      generatedEntries = map generateCustomEntry sortedEntries;
      finalEntries = lib.concatStringsSep "\n" generatedEntries;
    in
    finalEntries;

  # Generate only non-NixOS custom entries for extraEntries
  # NixOS main entries are auto-generated by the system
  generateCustomEntry = entry:
    if entry.type == "os" && entry.osType == "nixos" then
      "" # Skip NixOS entries - let the system handle them
    else if entry.type == "firmware" then
      ''
        menuentry "${entry.name}" {
          fwsetup
        }
      ''
    else if entry.type == "submenu" then
      ''
        submenu "${entry.name}" {
          ${generateSubmenuEntries entry.submenu}
        }
      ''
    else
      generateGrubEntry entry;

  # Generate all custom menu entries (excluding main NixOS)
  customMenuEntries = 
    let
      filteredEntries = lib.filter (entry: 
        !(entry.type == "os" && entry.osType == "nixos")
      ) cfg.entries;
      sortedEntries = lib.sort (a: b: a.priority < b.priority) filteredEntries;
      generatedEntries = map generateCustomEntry sortedEntries;
      finalEntries = lib.concatStringsSep "\n" generatedEntries;
    in
    finalEntries
    # Add feature-generated entries after custom entries  
    + lib.optionalString cfg.features.memtest ''

menuentry "Memory Test (memtest86+)" {
  linux /boot/memtest86+.bin
}
    ''
    + lib.optionalString cfg.features.recovery ''

submenu "Recovery Options" {
  menuentry "NixOS Recovery Mode" {
    # Recovery boot parameters
    linux /boot/nixos/kernel init=/bin/sh
  }
}
    '';

  # Get theme - either a package (if default.nix exists) or a path
  getTheme = themeName:
    if themeName == null then
      null
    else
      let
        themeDir = ./. + "/themes/${themeName}";
        themePackageFile = themeDir + "/default.nix";
      in
      if builtins.pathExists themePackageFile then
        # Import as package if default.nix exists
        import themePackageFile { inherit pkgs; }
      else
        # Use as static path
        helpers.getThemePath "grub" themeName;

  # Generate main menu config for chained themes
  generateMainMenuConfig = chainedCfg:
    let
      mainTheme = getTheme chainedCfg.mainTheme;
      menuEntries = lib.concatStringsSep "\n" (lib.imap0 (i: entry: ''
        menuentry "${entry}" {
          configfile $prefix/grub.cfg
        }
      '') chainedCfg.mainMenuEntries);
    in
    ''
      # Main Menu Configuration for Chained Theme System
      # Generated by NixOS Universal Bootloader System
      
      set timeout=${toString cfg.primary.timeout}
      set default=0
      
      # Set theme for main menu
      set theme=$prefix/themes/${chainedCfg.mainTheme}/theme.txt
      
      # Main menu entries
      ${menuEntries}
      
      # Fallback entry to boot normally
      menuentry "Continue to Boot Menu" {
        configfile $prefix/grub.cfg
      }
    '';

  # Generate 05_twomenus script for chained themes
  generate05TwomenusScript = ''
    #!/bin/sh
    # 05_twomenus - Double menu support for chained themes
    # Generated by NixOS Universal Bootloader System
    
    cat << 'EOF'
    # Double menu logic
    if [ -n "$config_file" ] && [ -z "$chosen" ]; then
      # Load main menu if config_file is set and no choice has been made
      configfile $prefix/$config_file
    fi
    EOF
  '';

  # Determine which theme to use based on chained theme configuration
  effectiveTheme = 
    if cfg.primary.chainedTheme != null && cfg.primary.chainedTheme.enable then
      # Use submenu theme for the main grub.cfg when chained theme is enabled
      getTheme cfg.primary.chainedTheme.submenuTheme
    else
      # Use regular theme
      getTheme cfg.primary.theme;

in
lib.mkIf (cfg.primary.type == "grub") {
  # Enable GRUB and configure it
  boot.loader = {
    grub = {
      enable = true;
      device = "nodev"; # For UEFI systems
      efiSupport = true;
      useOSProber = true; # Detect other operating systems automatically

      # Custom configuration including menu entries
      extraConfig = customGrubConfig;

      # Theme support - use effective theme (considers chained themes)
      theme = lib.mkIf (effectiveTheme != null) effectiveTheme;

      # Custom NixOS name for main entry
      configurationName = cfg.primary.customName;
      
      # Try to customize the generations submenu name
      subEntryOptions = ''--class nixos --submenu "Generations"'';
      
      # Modify the generated grub.cfg to rename the submenu
      extraInstallCommands = ''
        # Replace "All configurations" with "Generations" in the submenu title
        if [ -f /boot/grub/grub.cfg ]; then
          ${pkgs.gnused}/bin/sed -i 's/submenu "NixOS - All configurations"/submenu "NixOS - Generations"/g' /boot/grub/grub.cfg || true
        fi
        
        ${lib.optionalString (cfg.primary.chainedTheme != null && cfg.primary.chainedTheme.enable) ''
          # Generate chained theme files
          echo "Setting up chained theme system..."
          
          # Generate main menu config
          cat > /boot/grub/mainmenu.cfg << 'EOF'
          ${generateMainMenuConfig cfg.primary.chainedTheme}
          EOF
          
          # Generate and install 05_twomenus script
          cat > /etc/grub.d/05_twomenus << 'EOF'
          ${generate05TwomenusScript}
          EOF
          chmod +x /etc/grub.d/05_twomenus
          
          # Set the environment variable to enable chained theme
          ${pkgs.grub2}/bin/grub-editenv /boot/grub/grubenv set config_file=mainmenu.cfg
          
          echo "Chained theme system enabled!"
          echo "Main theme: ${cfg.primary.chainedTheme.mainTheme}"
          echo "Submenu theme: ${cfg.primary.chainedTheme.submenuTheme}"
        ''}
      '';

      # Use extraEntries to place submenu after main NixOS entry
      extraEntriesBeforeNixOS = false;
      extraEntries = testSubmenu;
    };

    # Timeout configuration (moved from grub.timeout)
    timeout = cfg.primary.timeout;
  };

  # Install additional packages for advanced features
  environment.systemPackages =
    with pkgs;
    [
      grub2
      efibootmgr
    ]
    ++ lib.optionals cfg.features.memtest [
      memtest86plus
    ]
    ++ lib.optionals cfg.features.chainloading [
      # Additional tools for chainloading
      grub2_efi
    ];

  # Create theme directories and files
  system.activationScripts.grubThemes = lib.mkIf (effectiveTheme != null) ''
    # Ensure GRUB theme directories exist
    mkdir -p /boot/grub/themes

    # Copy theme files based on configuration type
    ${lib.optionalString (cfg.primary.chainedTheme != null && cfg.primary.chainedTheme.enable) ''
      # Copy both themes for chained theme system
      echo "Setting up chained theme files..."
      
      # Copy main theme (e.g., minegrub)
      MAIN_THEME="${getTheme cfg.primary.chainedTheme.mainTheme}"
      if [ -d "$MAIN_THEME" ]; then
        echo "Copying main theme: ${cfg.primary.chainedTheme.mainTheme}"
        mkdir -p /boot/grub/themes/${cfg.primary.chainedTheme.mainTheme}
        cp -r "$MAIN_THEME"/* /boot/grub/themes/${cfg.primary.chainedTheme.mainTheme}/
      fi
      
      # Copy submenu theme (e.g., minegrub-world-sel)
      SUBMENU_THEME="${getTheme cfg.primary.chainedTheme.submenuTheme}"
      if [ -d "$SUBMENU_THEME" ]; then
        echo "Copying submenu theme: ${cfg.primary.chainedTheme.submenuTheme}"
        mkdir -p /boot/grub/themes/${cfg.primary.chainedTheme.submenuTheme}
        cp -r "$SUBMENU_THEME"/* /boot/grub/themes/${cfg.primary.chainedTheme.submenuTheme}/
      fi
      
      # Generate main menu config file
      cat > /boot/grub/mainmenu.cfg << 'EOF'
${generateMainMenuConfig cfg.primary.chainedTheme}
EOF
      
      # Generate 05_twomenus script
      cat > /etc/grub.d/05_twomenus << 'EOF'
${generateTwoMenusScript}
EOF
      chmod +x /etc/grub.d/05_twomenus
      
      # Ensure grub environment file exists
      mkdir -p /boot/grub
      touch /boot/grub/grubenv
      
      # Set up chained theme if not already configured
      if ! ${pkgs.grub2}/bin/grub-editenv /boot/grub/grubenv list | ${pkgs.gnugrep}/bin/grep -q "config_file=mainmenu.cfg"; then
        echo "Enabling chained theme system..."
        ${pkgs.grub2}/bin/grub-editenv /boot/grub/grubenv set config_file=mainmenu.cfg
      fi
    ''}

    # Copy single theme if not using chained themes
    ${lib.optionalString (cfg.primary.theme != null && !(cfg.primary.chainedTheme != null && cfg.primary.chainedTheme.enable)) ''
      THEME_PATH="${helpers.getThemePath "grub" cfg.primary.theme}"
      if [ -d "$THEME_PATH" ]; then
        cp -r "$THEME_PATH"/* /boot/grub/themes/
      fi
    ''}
  '';

  # Generate generations configuration for submenu
  system.activationScripts.grubGenerations = lib.mkIf cfg.features.generationsMenu.enable ''
    # Generate generations submenu configuration
    cat > /boot/grub/generations.cfg << 'EOF'
    # NixOS Generations Menu
    # This file is auto-generated

    ${lib.concatStringsSep "\n" (
      lib.genList (i: ''
        menuentry "Generation ${toString i}" {
          configfile /nix/var/nix/profiles/system-${toString i}-link/boot/grub/grub.cfg
        }
      '') cfg.features.generationsMenu.maxEntries
    )}
    EOF
  '';

  # Assertions for GRUB-specific requirements
  assertions = [
    {
      assertion = config.boot.loader.systemd-boot.enable == false;
      message = "Cannot use both GRUB and systemd-boot simultaneously";
    }
  ];
}
