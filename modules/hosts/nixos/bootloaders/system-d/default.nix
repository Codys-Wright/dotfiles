# systemd-boot Bootloader Implementation
# Limited theme support but excellent performance and simplicity
{
  lib,
  config,
  pkgs,
  ...
}:

let
  cfg = config.bootloaderConfig;
  helpers = cfg.helpers;

  # Generate systemd-boot entries
  generateSystemdEntry =
    entry:
    let
      entryConfig = {
        os = ''
          # Entry: ${entry.name}
          title ${entry.name}
          ${
            if entry.osType == "nixos" then
              ''
                linux /nixos/kernel
                initrd /nixos/initrd
                options init=/nix/store/*-nixos-system-*/init
              ''
            else if entry.osType == "windows" then
              ''
                efi /EFI/Microsoft/Boot/bootmgfw.efi
              ''
            else
              ''
                efi ${entry.device or "/EFI/BOOT/bootx64.efi"}
              ''
          }
        '';

        submenu = ''
          # Submenu: ${entry.name}
          # systemd-boot doesn't support submenus, creating chainload entry
          title ${entry.name}
          ${
            if entry.submenu.bootloader == "grub" then
              ''
                efi /EFI/grub/grubx64.efi
              ''
            else if entry.submenu.bootloader == "rEFInd" then
              ''
                efi /EFI/refind/refind_x64.efi
              ''
            else
              ''
                efi /EFI/systemd/systemd-bootx64.efi
              ''
          }
        '';

        generations = ''
          # NixOS Generations
          title ${entry.name}
          linux /nixos/kernel
          initrd /nixos/initrd
          options init=/nix/store/*-nixos-system-*/init systemd.unit=multi-user.target
        '';

        firmware = ''
          # Firmware Settings
          title ${entry.name}
          efi /EFI/systemd/systemd-bootx64.efi
          options systemd.reboot-to-firmware-setup
        '';
      };
    in
    entryConfig.${entry.type} or "";

  # Create boot entries directory structure
  bootEntries = lib.listToAttrs (
    lib.imap0 (i: entry: {
      name = "${toString (10 + i * 10)}-${
        lib.replaceStrings [ " " ] [ "_" ] (lib.toLower entry.name)
      }.conf";
      value = generateSystemdEntry entry;
    }) helpers.sortedEntries
  );

  # Generate loader configuration
  loaderConfig = ''
    # systemd-boot loader configuration
    # Generated by Universal Bootloader System

    timeout ${toString cfg.primary.timeout}
    default ${cfg.primary.customName}
    editor no

    # Console configuration
    console-mode auto

    ${lib.optionalString (cfg.primary.theme != null) ''
      # Theme settings (limited support)
      # systemd-boot themes are mainly console colors
    ''}
  '';

in
lib.mkIf (cfg.primary.type == "systemd-boot") {
  # Enable systemd-boot
  boot.loader = {
    grub.enable = false;

    systemd-boot = {
      enable = true;
      configurationLimit = lib.mkIf cfg.features.generationsMenu.enable cfg.features.generationsMenu.maxEntries;

      # Custom entries will be managed by our system
      extraEntries = lib.concatStringsSep "\n\n" (lib.attrValues bootEntries);

      # Editor disabled for security
      editor = false;

      # Console mode
      consoleMode = "auto";
    };

    # EFI configuration
    efi = {
      canTouchEfiVariables = true;
      efiSysMountPoint = "/boot";
    };

    timeout = cfg.primary.timeout;
  };

  # Install systemd-boot and related packages
  environment.systemPackages =
    with pkgs;
    [
      efibootmgr
      systemd
    ]
    ++ lib.optionals cfg.features.memtest [
      memtest86plus
    ];

  # systemd-boot configuration management
  system.activationScripts.systemdBootSetup = ''
    # Ensure systemd-boot directories exist
    mkdir -p /boot/EFI/systemd
    mkdir -p /boot/loader/entries

    # Generate loader configuration
    cat > /boot/loader/loader.conf << 'EOF'
    ${loaderConfig}
    EOF

    # Generate custom boot entries
    ${lib.concatStringsSep "\n" (
      lib.mapAttrsToList (filename: content: ''
        cat > /boot/loader/entries/${filename} << 'EOF'
        ${content}
        EOF
      '') bootEntries
    )}

    ${lib.optionalString cfg.features.memtest ''
      # Add memtest entry
      cat > /boot/loader/entries/99-memtest.conf << 'EOF'
      title Memory Test (memtest86+)
      efi /EFI/tools/memtest86.efi
      EOF
    ''}

    ${lib.optionalString cfg.features.recovery ''
      # Add recovery entry
      cat > /boot/loader/entries/98-recovery.conf << 'EOF'
      title NixOS Recovery Mode
      linux /nixos/kernel
      initrd /nixos/initrd
      options init=/bin/sh
      EOF
    ''}

    # Install systemd-boot (this is usually done automatically)
    if command -v bootctl &> /dev/null; then
      bootctl install --no-variables || true
    fi
  '';

  # systemd-boot specific kernel parameters
  boot.kernelParams = [
    "quiet"
    "splash"
    "loglevel=3"
    "systemd.show_status=auto"
    "rd.udev.log_level=3"
  ];

  # File system support for systemd-boot
  boot.supportedFilesystems = [ "vfat" ];

  # systemd-boot requires specific directory structure
  system.activationScripts.systemdBootDirs = ''
    # Create required directory structure
    mkdir -p /boot/EFI/BOOT
    mkdir -p /boot/EFI/systemd
    mkdir -p /boot/loader/entries
    mkdir -p /boot/nixos

    ${lib.optionalString cfg.features.chainloading ''
      # Create chainloading directory structure
      mkdir -p /boot/EFI/grub
      mkdir -p /boot/EFI/refind
      mkdir -p /boot/EFI/tools
    ''}
  '';

  # Limited theme support for systemd-boot
  system.activationScripts.systemdBootTheme = lib.mkIf (cfg.primary.theme != null) ''
    # systemd-boot has very limited theme support
    # Mainly console colors and simple customizations
    THEME_PATH="${helpers.getThemePath "systemd-boot" cfg.primary.theme}"

    if [ -d "$THEME_PATH" ]; then
      # Apply any theme-specific kernel parameters
      if [ -f "$THEME_PATH/kernel-params" ]; then
        # Theme-specific kernel parameters would be applied here
        echo "Theme kernel parameters found"
      fi

      # Copy any theme assets
      if [ -d "$THEME_PATH/assets" ]; then
        cp -r "$THEME_PATH/assets"/* /boot/EFI/systemd/ 2>/dev/null || true
      fi
    fi
  '';

  # Assertions for systemd-boot specific requirements
  assertions = [
    {
      assertion = config.boot.loader.grub.enable == false;
      message = "Cannot use both systemd-boot and GRUB simultaneously";
    }
    {
      assertion = config.boot.loader.efi.canTouchEfiVariables;
      message = "systemd-boot requires EFI variables support";
    }
    {
      assertion = pkgs.stdenv.targetPlatform.efiArch or null != null;
      message = "systemd-boot requires EFI system";
    }
  ];

  # Additional systemd-boot configuration
  systemd.services.systemd-boot-update = {
    description = "Update systemd-boot configuration";
    wantedBy = [ "multi-user.target" ];
    after = [ "local-fs.target" ];
    serviceConfig = {
      Type = "oneshot";
      ExecStart = "${pkgs.systemd}/bin/bootctl update";
      RemainAfterExit = true;
    };
  };
}
