# GRUB Bootloader Implementation
# Supports themes, hierarchical menus, and chainloading
{
  lib,
  config,
  pkgs,
  ...
}:

let
  cfg = config.bootloaderConfig;
  helpers = cfg.helpers;

  # Generate GRUB menu entries
  generateGrubEntry =
    entry:
    let
      entryConfig = {
        os = ''
          menuentry "${entry.name}" {
            ${
              if entry.osType == "windows" then
                ''
                  search --set=root --label WINDOWS
                  chainloader +1
                ''
              else if entry.osType == "nixos" then
                ''
                  # NixOS entry will be auto-generated
                ''
              else
                ''
                  # Custom OS entry
                  search --set=root --file /boot/grub/grub.cfg --hint hd0,gpt1
                  configfile /boot/grub/grub.cfg
                ''
            }
          }
        '';

        submenu = ''
          submenu "${entry.name}" {
            ${generateSubmenuEntries entry.submenu}
          }
        '';

        generations = ''
          submenu "${entry.name}" {
            # NixOS generations will be auto-populated by NixOS
            configfile /boot/grub/generations.cfg
          }
        '';

        firmware = ''
          menuentry "${entry.name}" {
            fwsetup
          }
        '';
      };
    in
    entryConfig.${entry.type} or "";

  # Generate entries for inside submenus (simpler than main menu entries)
  generateSubmenuEntry =
    entry:
    if entry.type == "firmware" then
      ''
        menuentry "${entry.name}" {
          fwsetup
        }
      ''
    else if entry.type == "os" && entry.osType == "nixos" then
      ''
        menuentry "${entry.name}" {
          # NixOS recovery entry - will be auto-populated
        }
      ''
    else
      ''
        menuentry "${entry.name}" {
          # Custom entry
        }
      '';

  # Generate submenu entries (for hierarchical navigation)
  generateSubmenuEntries =
    submenuCfg:
    if submenuCfg != null then
      let
        # Check if this is a generations submenu (empty entries)
        isGenerationsMenu = submenuCfg.entries == [ ];
        submenuEntries =
          if isGenerationsMenu then
            ''
              # NixOS generations will be auto-populated here by the bootloader
              # This is a placeholder that GRUB will replace with actual generation entries
            ''
          else
            lib.concatStringsSep "\n" (map generateSubmenuEntry submenuCfg.entries);
      in
      ''
        # Submenu using ${submenuCfg.bootloader}
        ${
          if submenuCfg.bootloader == "grub" then
            submenuEntries
          else
            ''
              # Chainload to ${submenuCfg.bootloader}
              menuentry "Load ${submenuCfg.bootloader}" {
                chainloader /boot/${submenuCfg.bootloader}/bootloader.efi
              }
            ''
        }
      ''
    else
      "";

  # Generate theme configuration
  themeConfig =
    let
      themePath = helpers.getThemePath "grub" cfg.primary.theme;
    in
    lib.optionalString (cfg.primary.theme != null) ''
      # GRUB Theme Configuration (handled by NixOS theme option)
      # Theme: ${cfg.primary.theme}
    '';

  # Generate custom GRUB configuration
  customGrubConfig = ''
    # Custom GRUB Configuration Generated by Universal Bootloader System

    ${lib.optionalString (cfg.primary.chainedTheme != null && cfg.primary.chainedTheme.enable) ''
      # Load environment variables (needed for double menu)
      if [ -s $prefix/grubenv ]; then
        load_env
      fi

      # Double menu logic (equivalent to 05_twomenus script)
      # Load main menu if no choice has been made yet and config_file is set
      if [ -z "''${chosen}" ]; then
        if [ "''${config_file}" ]; then
          configfile ''${prefix}/''${config_file}
        fi
      fi
    ''}

    set timeout=${toString cfg.primary.timeout}
    set default=0

    ${themeConfig}
  '';

  # Simple test submenu for extraEntries
  testSubmenu = ''
    submenu "More Options" {
      menuentry "BIOS/Firmware Settings" {
        fwsetup
      }

      menuentry "Test Entry 1" {
        # Just a test entry
        echo "Test entry selected"
        sleep 2
      }

      menuentry "Test Entry 2" {
        # Another test entry
        echo "Another test entry"
        sleep 2
      }
    }
  '';

  # Generate main menu config for chained themes - SIMPLIFIED VERSION
  generateSimpleMainMenu = chainedCfg: ''
    # Simple Minecraft-style main menu
    set theme=$prefix/themes/minegrub/theme.txt
    set timeout=10
    set default=0

    menuentry "Singleplayer" {
      # Load the main NixOS boot menu
      configfile $prefix/grub.cfg.backup
    }

    menuentry "Multiplayer" {
      # Alternative boot - same as singleplayer for now
      configfile $prefix/grub.cfg.backup
    }

    menuentry "Options" {
      # Boot to firmware settings
      fwsetup
    }
  '';

  # Generate only non-NixOS custom entries for extraEntries
  # NixOS main entries are auto-generated by the system
  generateCustomEntry =
    entry:
    if entry.type == "os" && entry.osType == "nixos" then
      "" # Skip NixOS entries - let the system handle them
    else if entry.type == "firmware" then
      ''
        menuentry "${entry.name}" {
          fwsetup
        }
      ''
    else if entry.type == "submenu" then
      ''
        submenu "${entry.name}" {
          ${generateSubmenuEntries entry.submenu}
        }
      ''
    else
      generateGrubEntry entry;

  # Generate all custom menu entries (excluding main NixOS)
  customMenuEntries =
    let
      filteredEntries = lib.filter (entry: !(entry.type == "os" && entry.osType == "nixos")) cfg.entries;
      sortedEntries = lib.sort (a: b: a.priority < b.priority) filteredEntries;
      generatedEntries = map generateCustomEntry sortedEntries;
      finalEntries = lib.concatStringsSep "\n" generatedEntries;
    in
    finalEntries
    # Add feature-generated entries after custom entries
    + lib.optionalString cfg.features.memtest ''

      menuentry "Memory Test (memtest86+)" {
        linux /boot/memtest86+.bin
      }
    ''
    + lib.optionalString cfg.features.recovery ''

      submenu "Recovery Options" {
        menuentry "NixOS Recovery Mode" {
          # Recovery boot parameters
          linux /boot/nixos/kernel init=/bin/sh
        }
      }
    '';

  # Get theme - either a package (if default.nix exists) or a path
  getTheme =
    themeName:
    if themeName == null then
      null
    else
      let
        themeDir = ./. + "/themes/${themeName}";
        themePackageFile = themeDir + "/default.nix";
      in
      if builtins.pathExists themePackageFile then
        # Import as package if default.nix exists
        import themePackageFile { inherit pkgs; }
      else
        # Use as static path
        helpers.getThemePath "grub" themeName;

  # Generate the mainmenu.cfg content (first screen with minegrub theme)
  generateMainMenuContent = chainedCfg: ''
    # Loading the theme and fonts
    loadfont $prefix/themes/minegrub/Minecraft30.pf2
    loadfont $prefix/themes/minegrub/Monocraft22.pf2
    insmod png
    set theme=$prefix/themes/minegrub/theme.txt
    export theme

    set timeout_style=menu
    set timeout=15

    ### NixOS VM Menu
    menuentry "              Singlebooter" {
    	configfile $prefix/grub.cfg
    }

    menuentry "              Onlinebooter" {
    	echo "Loading alternative boot options..."
    	configfile $prefix/grub.cfg
    }

    menuentry "           Uefi Setting Realm" $menuentry_id_option 'uefi-firmware' {
    	fwsetup
    }
  '';

  # Generate the 05_twomenus script content
  generate05TwomenusContent = ''
    #!/bin/sh
    exec tail -n +3 $0

    if [ -z "''${chosen}" ] ; then
    	if [ "''${config_file}" ] ; then
    		configfile ''${prefix}/''${config_file}
    	fi
    fi
  '';

  # Create the files as derivations for safer handling
  mainMenuConfigFile =
    if (cfg.primary.chainedTheme != null && cfg.primary.chainedTheme.enable) then
      pkgs.writeText "mainmenu.cfg" (generateMainMenuContent cfg.primary.chainedTheme)
    else
      null;

  twoMenusScriptFile =
    if (cfg.primary.chainedTheme != null && cfg.primary.chainedTheme.enable) then
      pkgs.writeText "05_twomenus" generate05TwomenusContent
    else
      null;

  # Determine which theme to use based on chained theme configuration
  effectiveTheme =
    if cfg.primary.chainedTheme != null && cfg.primary.chainedTheme.enable then
      # For chained themes, use world-selection as main GRUB theme (following install script)
      getTheme cfg.primary.chainedTheme.submenuTheme
    else
      # Use regular theme
      getTheme cfg.primary.theme;

in
lib.mkIf (cfg.primary.type == "grub") {
  # Enable GRUB and configure it
  boot.loader = {
    grub = {
      enable = true;
      device = "nodev"; # For UEFI systems
      efiSupport = true;
      useOSProber = true; # Detect other operating systems automatically

      # Custom configuration including menu entries
      extraConfig = customGrubConfig;

      # Theme support - use effective theme (considers chained themes)
      theme = lib.mkIf (effectiveTheme != null) effectiveTheme;

      # Custom NixOS name for main entry
      configurationName = cfg.primary.customName;

      # Try to customize the generations submenu name
      subEntryOptions = ''--class nixos --submenu "Generations"'';

      # Modify the generated grub.cfg to rename the submenu and set up chained theme
      extraInstallCommands = ''
        # Ensure coreutils is available for cp command
        export PATH="${pkgs.coreutils}/bin:$PATH"
        # Replace "All configurations" with "Generations" in the submenu title
        if [ -f /boot/grub/grub.cfg ]; then
          ${pkgs.gnused}/bin/sed -i 's/submenu "NixOS - All configurations"/submenu "NixOS - Generations"/g' /boot/grub/grub.cfg || true
        fi

        ${lib.optionalString (cfg.primary.chainedTheme != null && cfg.primary.chainedTheme.enable) ''
          # Set up chained theme system after GRUB config generation
          echo "Setting up chained theme environment..."

          # Copy mainmenu.cfg if it doesn't exist
          if [ -f "${mainMenuConfigFile}" ] && [ ! -f /boot/grub/mainmenu.cfg ]; then
            ${pkgs.coreutils}/bin/cp "${mainMenuConfigFile}" /boot/grub/mainmenu.cfg
            echo "Installed mainmenu.cfg"
          fi

          # Enable chained theme by setting environment variable
          if [ -f /boot/grub/grubenv ]; then
            ${pkgs.grub2}/bin/grub-editenv /boot/grub/grubenv set config_file=mainmenu.cfg
            echo "Enabled chained theme: minegrub -> minegrub-world-selection"
          fi
        ''}
      '';

      # Use extraEntries to place submenu after main NixOS entry
      extraEntriesBeforeNixOS = false;
      extraEntries = testSubmenu;
    };

    # Timeout configuration (moved from grub.timeout)
    timeout = cfg.primary.timeout;
  };

  # Install additional packages for advanced features
  environment.systemPackages =
    with pkgs;
    [
      grub2
      efibootmgr
    ]
    ++ lib.optionals cfg.features.memtest [
      memtest86plus
    ]
    ++ lib.optionals cfg.features.chainloading [
      # Additional tools for chainloading
      grub2_efi
    ];

  # Create theme directories and files
  system.activationScripts.grubThemes = lib.mkIf (effectiveTheme != null) ''
    # Ensure GRUB theme directories exist
    ${pkgs.coreutils}/bin/mkdir -p /boot/grub/themes

    # Copy theme files based on configuration type
    ${lib.optionalString (cfg.primary.chainedTheme != null && cfg.primary.chainedTheme.enable) ''
      # Simplified chained theme setup - copy both themes
      ${pkgs.coreutils}/bin/echo "Setting up simplified chained theme system..."

      # Copy main theme (for mainmenu.cfg) to /boot/grub/themes/minegrub/
      MAIN_THEME="${getTheme cfg.primary.chainedTheme.mainTheme}"
      if [ -d "$MAIN_THEME" ]; then
        ${pkgs.coreutils}/bin/echo "Copying main theme: ${cfg.primary.chainedTheme.mainTheme} -> /boot/grub/themes/minegrub/"
        ${pkgs.coreutils}/bin/mkdir -p /boot/grub/themes/minegrub
        ${pkgs.coreutils}/bin/cp -r "$MAIN_THEME"/* /boot/grub/themes/minegrub/
      fi

      # Copy submenu theme (for main GRUB) to /boot/grub/themes/minegrub-world-selection/
      SUBMENU_THEME="${getTheme cfg.primary.chainedTheme.submenuTheme}"
      if [ -d "$SUBMENU_THEME" ]; then
        ${pkgs.coreutils}/bin/echo "Copying submenu theme: ${cfg.primary.chainedTheme.submenuTheme} -> /boot/grub/themes/minegrub-world-selection/"
        ${pkgs.coreutils}/bin/mkdir -p /boot/grub/themes/minegrub-world-selection
        ${pkgs.coreutils}/bin/cp -r "$SUBMENU_THEME"/* /boot/grub/themes/minegrub-world-selection/
      fi

      # Chained theme setup is now handled via extraInstallCommands
    ''}

    # Copy single theme if not using chained themes
    ${lib.optionalString
      (
        cfg.primary.theme != null && !(cfg.primary.chainedTheme != null && cfg.primary.chainedTheme.enable)
      )
      ''
        THEME_PATH="${helpers.getThemePath "grub" cfg.primary.theme}"
        if [ -d "$THEME_PATH" ]; then
          ${pkgs.coreutils}/bin/cp -r "$THEME_PATH"/* /boot/grub/themes/
        fi
      ''
    }
  '';

  # Generate generations configuration for submenu
  system.activationScripts.grubGenerations = lib.mkIf cfg.features.generationsMenu.enable ''
    # Generate generations submenu configuration
    cat > /boot/grub/generations.cfg << 'EOF'
    # NixOS Generations Menu
    # This file is auto-generated

    ${lib.concatStringsSep "\n" (
      lib.genList (i: ''
        menuentry "Generation ${toString i}" {
          configfile /nix/var/nix/profiles/system-${toString i}-link/boot/grub/grub.cfg
        }
      '') cfg.features.generationsMenu.maxEntries
    )}
    EOF
  '';

  # Assertions for GRUB-specific requirements
  assertions = [
    {
      assertion = config.boot.loader.systemd-boot.enable == false;
      message = "Cannot use both GRUB and systemd-boot simultaneously";
    }
  ];
}
